\chapter{Control Design }
\hypertarget{control_design}{}\label{control_design}\index{Control Design@{Control Design}}
\hypertarget{control_design_autotoc_md16}{}\doxysubsection{\texorpdfstring{Overview}{Overview}}\label{control_design_autotoc_md16}
The Romi robot uses a layered control architecture that builds progressively from open-\/loop motor actuation to closed-\/loop velocity control and finally to high-\/level line-\/following behavior. Control design focused on achieving stable, repeatable motion rather than maximizing raw speed, allowing the robot to behave predictably across different operating conditions and battery states.

This page highlights the evolution of the motor control system and the final closed-\/loop structure used during line-\/following operation.

\DoxyHorRuler{0}
\hypertarget{control_design_autotoc_md18}{}\doxysubsection{\texorpdfstring{Motor Modeling and System Identification}{Motor Modeling and System Identification}}\label{control_design_autotoc_md18}
Initial motor characterization was performed using open-\/loop effort tests to establish approximate system gain and time constant. These tests provided insight into motor dynamics and informed early controller tuning.

Open-\/loop data was used to estimate\+:
\begin{DoxyItemize}
\item Steady-\/state velocity versus applied effort
\item Approximate motor time constant
\item Relative left/right motor behavior
\end{DoxyItemize}

These results guided the selection of initial proportional gains before transitioning to closed-\/loop control.

\DoxyHorRuler{0}
\hypertarget{control_design_autotoc_md20}{}\doxysubsection{\texorpdfstring{Velocity Measurement Improvements}{Velocity Measurement Improvements}}\label{control_design_autotoc_md20}
Early velocity measurements derived from encoder counts exhibited significant noise due to short sampling intervals and quantization effects. Several improvements were made to address this\+:


\begin{DoxyItemize}
\item Increased the motor control task period to improve measurement resolution
\item Revised encoder velocity calculations to reduce numerical noise
\item Ensured consistent timing between successive encoder reads
\end{DoxyItemize}

The progression below shows the improvement in velocity signal quality across successive step-\/response tests.

  

\DoxyHorRuler{0}
\hypertarget{control_design_autotoc_md22}{}\doxysubsection{\texorpdfstring{Closed-\/\+Loop Velocity Control}{Closed-\/\+Loop Velocity Control}}\label{control_design_autotoc_md22}
Closed-\/loop velocity control was implemented using a proportional–integral (PI) controller operating on each wheel independently. Encoder feedback provides continuous velocity measurements, allowing the controller to reject disturbances and track commanded setpoints more consistently than open-\/loop control.

Controller tuning was performed empirically by evaluating step responses across a range of gains and setpoints. Gains were selected to balance responsiveness with stability while avoiding excessive overshoot or oscillation.



\DoxyHorRuler{0}
\hypertarget{control_design_autotoc_md24}{}\doxysubsection{\texorpdfstring{Cascaded Control Structure}{Cascaded Control Structure}}\label{control_design_autotoc_md24}
Line following is implemented using a cascaded control structure. An outer loop interprets reflectance sensor measurements to generate a steering correction, while inner velocity loops regulate individual wheel speeds.

This separation allows the line-\/following logic to operate independently of motor dynamics and improves robustness to disturbances such as curvature changes or brief sensor dropout.



\DoxyHorRuler{0}
\hypertarget{control_design_autotoc_md26}{}\doxysubsection{\texorpdfstring{Discussion}{Discussion}}\label{control_design_autotoc_md26}
Implementing closed-\/loop velocity control significantly improved the robot’s repeatability and predictability. Improvements to encoder velocity estimation were critical; controller performance was ultimately limited more by measurement quality than by controller structure.

This layered approach simplified debugging and allowed individual components of the system to be validated independently before full integration with line-\/following behavior. 